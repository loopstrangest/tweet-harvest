// Word Cloud module for generating and exporting word clouds
export class WordCloudManager {
  constructor(api, tweetManager = null) {
    this.api = api;
    this.tweetManager = tweetManager;
    this.currentWordData = null;
    this.wordCloudGenerationController = null;

    // Check WordCloud2.js availability
    this.checkWordCloudLibrary();
  }

  checkWordCloudLibrary() {
    // Wait a bit for library to load
    setTimeout(() => {
      if (typeof WordCloud === "undefined") {
        console.warn(
          "WordCloud2.js library not detected - will use fallback rendering"
        );
      } else {
      }
    }, 1000);
  }

  autoGenerateWordCloud(account) {
    // Cancel any existing word cloud generation
    if (this.wordCloudGenerationController) {
      this.wordCloudGenerationController.abort();
    }

    // Start automatic generation in the background
    this.generateWordCloud(account, true);
  }

  async generateWordCloud(account, isAutoGenerated = false) {
    if (!account) {
      if (!isAutoGenerated) {
        this.showError("Please search for an account first");
      }
      return;
    }

    // Cancel any existing generation
    if (this.wordCloudGenerationController) {
      this.wordCloudGenerationController.abort();
    }

    // Create new AbortController for this generation
    this.wordCloudGenerationController = new AbortController();
    const signal = this.wordCloudGenerationController.signal;

    const exportBtn = document.getElementById("exportWordCloud");
    const placeholder = document.querySelector(".wordcloud-placeholder");
    const progress = document.getElementById("wordCloudProgress");
    const container = document.getElementById("wordCloudContainer");

    // Show progress, hide placeholder, start filling animation
    placeholder.classList.add("hidden");
    progress.classList.remove("hidden");
    container.classList.add("filling");

    // Change tab icon to loading spinner
    const wordCloudTab = document.querySelector('[data-tab="wordcloud"] i');
    if (wordCloudTab) {
      wordCloudTab.className = "fas fa-spinner fa-spin";
    }

    try {
      // Check if cancelled before starting
      if (signal.aborted) {
        throw new Error("Generation cancelled");
      }

      // Use cached tweets if available, otherwise fetch with progress
      let allTweets;
      if (this.tweetManager && this.tweetManager.getAllTweets().length > 0) {
        allTweets = this.tweetManager.getTweetsForWordCloud();
      } else {
        allTweets = await this.fetchAllTweetsWithProgress(account, signal);
      }

      if (allTweets.length === 0) {
        throw new Error("No tweets found to analyze");
      }

      // Check if cancelled after fetching
      if (signal.aborted) {
        throw new Error("Generation cancelled");
      }

      // Update progress to processing
      document.getElementById("progressText").textContent =
        "Processing tweets...";

      // Process tweets into word frequency data
      const wordData = this.processTextForWordCloud(allTweets);

      // Check if cancelled after processing
      if (signal.aborted) {
        throw new Error("Generation cancelled");
      }

      if (wordData.length === 0) {
        throw new Error("No meaningful words found in tweets");
      }

      // Update progress to rendering
      document.getElementById("progressText").textContent =
        "Creating word cloud...";

      // Small delay to show the progress update
      await new Promise((resolve) => setTimeout(resolve, 100));

      // Render the word cloud
      this.renderWordCloud(wordData);

      exportBtn.disabled = false;
    } catch (error) {
      console.error("Word cloud generation error:", error);

      // Handle different error scenarios
      if (error.message === "Generation cancelled") {
      } else if (isAutoGenerated) {
        // For auto-generated, log error but don't show user error popup
        console.error("Auto word cloud generation failed:", error.message);
        // Still show placeholder for failed auto-generation
        placeholder.classList.remove("hidden");
      } else {
        // For manual generation, show the error to the user
        this.showError(`Failed to generate word cloud: ${error.message}`);
        placeholder.classList.remove("hidden");
      }
    } finally {
      progress.classList.add("hidden");
      container.classList.remove("filling");

      // Restore tab icon to cloud
      const wordCloudTab = document.querySelector('[data-tab="wordcloud"] i');
      if (wordCloudTab) {
        wordCloudTab.className = "fas fa-cloud";
      }

      // Clear the controller reference
      this.wordCloudGenerationController = null;
    }
  }

  async fetchAllTweetsWithProgress(account, signal = null) {
    const allTweets = [];
    let offset = 0;
    const limit = 1000; // Fetch in batches

    // First, get the total tweet count for progress calculation
    const totalTweets = account.num_tweets || 0;
    let fetchedCount = 0;

    while (true) {
      // Check if cancelled before making API call
      if (signal && signal.aborted) {
        throw new Error("Generation cancelled");
      }

      const batch = await this.api.apiCall("tweets", {
        account_id: `eq.${account.account_id}`,
        select: "full_text",
        limit: limit.toString(),
        offset: offset.toString(),
      });

      if (!batch || batch.length === 0) break;

      allTweets.push(...batch);
      fetchedCount += batch.length;

      // Update progress
      const percentage =
        totalTweets > 0 ? Math.min((fetchedCount / totalTweets) * 100, 100) : 0;
      const container = document.getElementById("wordCloudContainer");
      container.style.setProperty("--progress-height", `${percentage}%`);
      document.getElementById("progressText").textContent =
        "Fetching tweets...";
      document.getElementById("progressPercent").textContent = `${Math.round(
        percentage
      )}%`;

      offset += limit;

      if (batch.length < limit) break; // Last batch

      // Small delay to prevent overwhelming the API
      await new Promise((resolve) => setTimeout(resolve, 50));
    }

    return allTweets;
  }

  processTextForWordCloud(tweets) {
    const wordFreq = {};
    const stopWords = new Set([
      // English stop words
      "i",
      "me",
      "my",
      "myself",
      "we",
      "our",
      "ours",
      "ourselves",
      "you",
      "your",
      "yours",
      "yourself",
      "yourselves",
      "he",
      "him",
      "his",
      "himself",
      "she",
      "her",
      "hers",
      "herself",
      "it",
      "its",
      "itself",
      "they",
      "them",
      "their",
      "theirs",
      "themselves",
      "what",
      "which",
      "who",
      "whom",
      "this",
      "that",
      "these",
      "those",
      "people",
      "about",
      "from",
      "would",
      "also",
      "am",
      "is",
      "are",
      "was",
      "were",
      "be",
      "been",
      "being",
      "have",
      "has",
      "had",
      "having",
      "do",
      "does",
      "did",
      "doing",
      "a",
      "an",
      "the",
      "and",
      "but",
      "if",
      "or",
      "because",
      "as",
      "until",
      "while",
      "of",
      "at",
      "by",
      "for",
      "with",
      "through",
      "during",
      "before",
      "after",
      "above",
      "below",
      "up",
      "down",
      "in",
      "out",
      "on",
      "off",
      "over",
      "under",
      "again",
      "further",
      "then",
      "once",
      "here",
      "there",
      "when",
      "where",
      "why",
      "how",
      "all",
      "any",
      "both",
      "each",
      "few",
      "more",
      "most",
      "other",
      "some",
      "such",
      "no",
      "nor",
      "not",
      "only",
      "own",
      "same",
      "so",
      "than",
      "too",
      "very",
      "s",
      "t",
      "can",
      "will",
      "just",
      "don",
      "should",
      "now",
      "d",
      "ll",
      "m",
      "o",
      "re",
      "ve",
      "y",
      "ain",
      "aren",
      "couldn",
      "didn",
      "doesn",
      "hadn",
      "hasn",
      "haven",
      "isn",
      "ma",
      "mightn",
      "mustn",
      "needn",
      "shan",
      "shouldn",
      "wasn",
      "weren",
      "won",
      "wouldn",
      "rt",
      "via",
      "get",
      "got",
      // Twitter specific
      "twitter",
      "tweet",
      "retweet",
      "rt",
      "via",
      "http",
      "https",
      "www",
      "com",
      "co",
      "like",
      "follow",
      "following",
      "followers",
      "dm",
      "pm",
      "lol",
      "lmao",
      "omg",
      "wtf",
      "fyi",
      "btw",
      "imo",
      "imho",
      "tho",
      "gonna",
      "wanna",
      "gotta",
      "kinda",
      "sorta",
      "ya",
      "yeah",
      "yep",
      "nah",
      "nope",
      "ok",
      "okay",
      "thanks",
      "thank",
      "thx",
      "ty",
      // Single letters and short words that aren't meaningful
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "j",
      "k",
      "l",
      "n",
      "p",
      "q",
      "r",
      "u",
      "v",
      "w",
      "x",
      "z",
      "ah",
      "oh",
      "eh",
      "um",
      "uh",
      "hmm",
      "hm",
      "er",
      "erm",
      "amp",
    ]);

    tweets.forEach((tweet) => {
      const text = tweet.full_text || "";

      // Remove URLs, mentions, hashtags symbols, and other Twitter-specific elements
      const cleanText = text
        .replace(/https?:\/\/\S+/g, "") // Remove URLs
        .replace(/@\w+/g, "") // Remove mentions
        .replace(/#/g, " ") // Remove hashtag symbols but keep the text
        .replace(/[^\w\s]/g, " ") // Remove punctuation and special characters
        .toLowerCase()
        .trim();

      // Split into words and count frequency
      const words = cleanText.split(/\s+/).filter((word) => {
        return (
          word.length > 2 &&
          !stopWords.has(word) &&
          !/^\d+$/.test(word) && // Skip pure numbers
          !/^[a-z]{1,2}$/.test(word)
        ); // Skip 1-2 letter combinations
      });

      words.forEach((word) => {
        wordFreq[word] = (wordFreq[word] || 0) + 1;
      });
    });

    // Convert to array and sort by frequency
    return Object.entries(wordFreq)
      .map(([word, count]) => ({ text: word, size: count }))
      .sort((a, b) => b.size - a.size)
      .slice(0, 200); // Limit to top 200 words for performance
  }

  renderWordCloud(wordData) {
    if (!wordData || wordData.length === 0) {
      console.error("No word data available for word cloud");
      return;
    }

    // Clear existing canvas
    const container = document.getElementById("wordCloudContainer");

    const existingCanvas = container.querySelector("#wordCloudCanvas");
    if (existingCanvas) {
      existingCanvas.remove();
    }

    // Create basic canvas - exactly like the working example
    const canvas = document.createElement("canvas");
    canvas.id = "wordCloudCanvas";
    canvas.width = 500;
    canvas.height = 500;
    canvas.style.width = "400px";
    canvas.style.height = "400px";
    canvas.style.display = "block";
    canvas.style.margin = "0 auto";

    // Add to container immediately
    container.appendChild(canvas);

    // Store word data for export
    this.currentWordData = wordData;

    // Convert to the exact format WordCloud2 expects: [text, frequency]
    const wordList = wordData
      .slice(0, 100)
      .map((word) => [word.text, word.size]);

    try {
      if (typeof WordCloud === "undefined") {
        console.error("WordCloud2.js library not found!");
        // Show a simple text message instead
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, 400, 400);
        ctx.fillStyle = "#008000";
        ctx.font = "bold 16px Arial";
        ctx.textAlign = "center";
        ctx.fillText("WordCloud2.js library not loaded", 200, 200);
        return;
      }

      // Fixed configuration to prevent canvas scaling issues
      WordCloud(canvas, {
        list: wordList,
        gridSize: Math.round(Math.sqrt(wordList.length) / 2) || 4, // Dynamic grid size
        weightFactor: function (size) {
          // Scale based on word frequency
          return Math.sqrt(size) * 3;
        },
        fontFamily: "Arial, sans-serif",
        color: function () {
          const colors = [
            "#004b23",
            "#006400",
            "#007200",
            "#008000",
            "#38b000",
            "#70e000",
            "#9ef01a",
          ];
          return colors[Math.floor(Math.random() * colors.length)];
        },
        rotateRatio: 0.3,
        rotationSteps: 2,
        backgroundColor: "#ffffff",
        drawOutOfBound: false,
        shrinkToFit: true,
        minSize: 4, // Prevent tiny words
        origin: [200, 200], // Fixed center point
      });
    } catch (error) {
      console.error("WordCloud2 ERROR:", error);

      // Emergency fallback - show we tried
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, 400, 400);
      ctx.fillStyle = "#ff0000";
      ctx.font = "bold 16px Arial";
      ctx.textAlign = "center";
      ctx.fillText("WordCloud2 Error: " + error.message, 200, 200);
    }
  }

  renderFallbackWordCloud(ctx, wordData, displaySize, colors) {
    // Simple fallback rendering when WordCloud2.js fails
    const maxFreq = wordData[0].size;
    const minFreq = wordData[wordData.length - 1].size || 1;
    const placedWords = [];

    // Helper functions for fallback rendering
    const getTextDimensions = (text, fontSize) => {
      ctx.font = `bold ${fontSize}px Inter, Arial, sans-serif`;
      const metrics = ctx.measureText(text);
      return { width: metrics.width, height: fontSize };
    };

    const isOverlapping = (rect1, rect2, padding = 3) => {
      return (
        rect1.x < rect2.x + rect2.width + padding &&
        rect1.x + rect1.width + padding > rect2.x &&
        rect1.y < rect2.y + rect2.height + padding &&
        rect1.y + rect1.height + padding > rect2.y
      );
    };

    const tryPlaceWord = (word, fontSize, color) => {
      const dimensions = getTextDimensions(word.text, fontSize);
      const attempts = 150;

      for (let attempt = 0; attempt < attempts; attempt++) {
        // Spiral placement from center
        const angle = attempt * 0.5;
        const radius = Math.sqrt(attempt) * 2;

        const x =
          displaySize / 2 + Math.cos(angle) * radius - dimensions.width / 2;
        const y =
          displaySize / 2 + Math.sin(angle) * radius - dimensions.height / 2;

        // Check bounds
        const padding = 15;
        if (
          x < padding ||
          y < padding ||
          x + dimensions.width > displaySize - padding ||
          y + dimensions.height > displaySize - padding
        ) {
          continue;
        }

        const rect = {
          x,
          y,
          width: dimensions.width,
          height: dimensions.height,
        };

        // Check for overlaps
        const hasOverlap = placedWords.some((placed) =>
          isOverlapping(rect, placed)
        );

        if (!hasOverlap) {
          // Place the word
          ctx.font = `bold ${fontSize}px Inter, Arial, sans-serif`;
          ctx.fillStyle = color;
          ctx.textAlign = "left";
          ctx.textBaseline = "top";
          ctx.fillText(word.text, x, y);

          placedWords.push(rect);
          return true;
        }
      }
      return false;
    };

    // Place words with simple algorithm
    const wordsToPlace = wordData.slice(0, 50); // Limit for performance
    wordsToPlace.forEach((word, index) => {
      const normalizedFreq = (word.size - minFreq) / (maxFreq - minFreq || 1);
      const fontSize = 12 + Math.floor(normalizedFreq * 24); // 12-36px range
      const color = colors[index % colors.length];

      tryPlaceWord(word, fontSize, color);
    });
  }

  renderFallbackExport(ctx, wordData, canvasSize, colors) {
    // Simple fallback for export
    const maxFreq = wordData[0].size;
    const minFreq = wordData[wordData.length - 1].size || 1;
    const placedWords = [];

    // Helper functions
    const getTextDimensions = (text, fontSize) => {
      ctx.font = `bold ${fontSize}px Inter, Arial, sans-serif`;
      const metrics = ctx.measureText(text);
      return { width: metrics.width, height: fontSize };
    };

    const isOverlapping = (rect1, rect2, padding = 8) => {
      return (
        rect1.x < rect2.x + rect2.width + padding &&
        rect1.x + rect1.width + padding > rect2.x &&
        rect1.y < rect2.y + rect2.height + padding &&
        rect1.y + rect1.height + padding > rect2.y
      );
    };

    const tryPlaceWord = (word, fontSize, color) => {
      const dimensions = getTextDimensions(word.text, fontSize);
      const attempts = 200;

      for (let attempt = 0; attempt < attempts; attempt++) {
        const angle = attempt * 0.4;
        const radius = Math.sqrt(attempt) * 3;

        const x =
          canvasSize / 2 + Math.cos(angle) * radius - dimensions.width / 2;
        const y =
          canvasSize / 2 + Math.sin(angle) * radius - dimensions.height / 2;

        const padding = canvasSize * 0.05;
        if (
          x < padding ||
          y < padding ||
          x + dimensions.width > canvasSize - padding ||
          y + dimensions.height > canvasSize - padding
        ) {
          continue;
        }

        const rect = {
          x,
          y,
          width: dimensions.width,
          height: dimensions.height,
        };
        const hasOverlap = placedWords.some((placed) =>
          isOverlapping(rect, placed)
        );

        if (!hasOverlap) {
          ctx.font = `bold ${fontSize}px Inter, Arial, sans-serif`;
          ctx.fillStyle = color;
          ctx.textAlign = "left";
          ctx.textBaseline = "top";
          ctx.fillText(word.text, x, y);

          placedWords.push(rect);
          return true;
        }
      }
      return false;
    };

    // Place words for export
    wordData.slice(0, 80).forEach((word, index) => {
      const normalizedFreq = (word.size - minFreq) / (maxFreq - minFreq || 1);
      const fontSize = 16 + Math.floor(normalizedFreq * 48); // 16-64px range for export
      const color = colors[index % colors.length];

      tryPlaceWord(word, fontSize, color);
    });
  }

  async exportWordCloud(account) {
    const canvas = document.getElementById("wordCloudCanvas");
    if (!canvas) {
      this.showError("No word cloud to export");
      return;
    }

    if (!account) {
      this.showError("No account information available for export");
      return;
    }

    const exportBtn = document.getElementById("exportWordCloud");
    const originalText = exportBtn.innerHTML;

    exportBtn.disabled = true;
    exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Exporting...';

    try {
      // Create a high-quality export canvas - slightly taller than wide
      const exportWidth = 600;
      const exportHeight = 630; // 5% taller than width
      const exportCanvas = document.createElement("canvas");
      exportCanvas.width = exportWidth;
      exportCanvas.height = exportHeight;

      const exportCtx = exportCanvas.getContext("2d");

      // Fill with white background
      exportCtx.fillStyle = "#ffffff";
      exportCtx.fillRect(0, 0, exportWidth, exportHeight);

      // Generate green color palette for export
      const colors = [
        "#004b23",
        "#006400",
        "#007200",
        "#008000",
        "#38b000",
        "#70e000",
        "#9ef01a",
      ];

      // Convert word data to format expected by WordCloud2
      const wordList = this.currentWordData.map((word) => [
        word.text,
        word.size,
      ]);

      // Copy word cloud from display canvas to export canvas
      const displayCanvas = document.getElementById("wordCloudCanvas");
      if (displayCanvas) {
        // Keep word cloud square and centered in the image
        const wordCloudSize = Math.min(exportWidth, exportHeight * 0.95);
        const wordCloudX = (exportWidth - wordCloudSize) / 2;
        const wordCloudY = 0;
        exportCtx.drawImage(
          displayCanvas,
          wordCloudX,
          wordCloudY,
          wordCloudSize,
          wordCloudSize
        );
      } else {
        exportCtx.fillStyle = "#008000";
        exportCtx.font = "bold 24px Arial";
        exportCtx.textAlign = "center";
        exportCtx.fillText(
          "Word Cloud Export",
          exportWidth / 2,
          exportHeight / 2
        );
      }

      // Draw username at bottom left in bold italic
      exportCtx.fillStyle = "#2d5016";
      exportCtx.font = "bold italic 18px Arial";
      exportCtx.textAlign = "left";
      exportCtx.textBaseline = "bottom";
      exportCtx.fillText(`@${account.username}`, 10, exportHeight - 10);

      // Draw website URL at bottom right
      exportCtx.fillStyle = "#2d5016";
      exportCtx.font = "bold 16px Arial";
      exportCtx.textAlign = "right";
      exportCtx.textBaseline = "bottom";
      exportCtx.fillText(
        "strangestloop.io/tweet-harvest",
        exportWidth - 10,
        exportHeight - 10
      );

      // Create download link
      const link = document.createElement("a");
      link.download = `wordcloud-${account.username}.png`;
      link.href = exportCanvas.toDataURL("image/png");

      // Trigger download
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error("Export error:", error);
      this.showError("Failed to export word cloud");
    } finally {
      exportBtn.disabled = false;
      exportBtn.innerHTML = originalText;
    }
  }

  clearWordCloud() {
    // Remove existing canvas
    const existingCanvas = document.getElementById("wordCloudCanvas");
    if (existingCanvas) {
      existingCanvas.remove();
    }

    // Show placeholder again
    const placeholder = document.querySelector(".wordcloud-placeholder");
    const progress = document.getElementById("wordCloudProgress");

    if (placeholder) placeholder.classList.remove("hidden");
    if (progress) progress.classList.add("hidden");

    // Reset word cloud data
    this.currentWordData = null;

    // Disable export button
    const exportBtn = document.getElementById("exportWordCloud");
    if (exportBtn) {
      exportBtn.disabled = true;
    }
  }

  showError(message) {
    const errorMsg = document.getElementById("errorMessage");
    errorMsg.textContent = message;
    errorMsg.classList.remove("hidden");
  }
}
